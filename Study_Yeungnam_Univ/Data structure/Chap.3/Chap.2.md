# C로 배우는 자료구조 / Chap.2 자료구조 시작하기

# Ⅰ. 소프트웨어 생명 주기(개발 주기)

---

소프트웨어 개발 단계와 방법을 이해하고, 체계적으로 개발+관리하기 위해서 소프트웨어의 개발과정을 몇 단계로 구분한다.

이를 소프트웨어 생명 주기(Software Life Cycle) 또는 소프트웨어 개발 주기 (Software Development Life Cycle)라고 하고,

일반적으로 **6단계**로 구분한다.

1. 요구분석
2. 시스템 명세
3. 설계
4. 구현
5. 테스트
6. 유지보수


![Untitled](https://user-images.githubusercontent.com/87224039/135745585-93aa3676-8626-45ac-90d7-d7a560d93191.png)


## Ⅰ-1. 요구분석

요구 분석은 문제 분석이라고도 하는데, 이 단계에서 개발할 소프트웨어의 기능과 제약 조건, 목표 등을 소프트웨어 사용자와 함께 명확히 정의한다.

## Ⅰ-2. 시스템 명세

시스템 명세 단계는, 시스템이 무엇을 수행해야 하는지를 정의하는 단계이다.

## Ⅰ-3. 설계

설계는 시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계로 구분할 수 있고, 그 설계 방법에는 하향식 설계(Top-Down Design) 방법, 상향식 설계(Down-Top Design) 방법, 객체지향 설계(Object-Oriented Design) 방법이 있다.

- 시스템 구조 설계
    
    시스템을 구성하는 내부 프로그램이나 모듈 간의 관계와 구조를 설계한다.
    
- 프로그램 설계
    
    프로그램 내의 각 모듈에서의 처리 절차나 알고리즘을 설계한다.
    
- 사용자 인터페이스 설계
    
    시스템을 사용하는 사용자에게 보여지는 프로그램을 설계한다.
    
- 하향식 설계 방법(Top-Down Design)
    
    무엇을 수행할 것인지를 정의하는 단계에서 시작하여 각 단계를 내려갈수록 수행 방법을 구체적으로 정의하고 세분화하는 방법이다. 하향식 설계 방법은 하위 단계로 갈수록 구체적인 세부 문제를 정의한다. 마지막 최하위 단계로 분할(Divide)된 작은 단위의 문제들을 각각 처리함으로써 전체 문제를 해결(Conquer)한다. 이러한 분할 정복(Divide and Conquer)이라고 한다.
    
![Untitled 1](https://user-images.githubusercontent.com/87224039/135745587-08a37a3f-abaf-4b8d-af81-4f0159a28041.png)


    
- 상향식 설계 방법(Bottom-Up Design)
    
    하향식 설계 방법과 반대로, 최하위 단계에 있는 작은 단위를 먼저 결정하고 이를 이용하여 좀 더 큰 상위 단계의 문제를 해결하는 방법이다. 최하위 단위의 문제들에 대해 기존에 개발되어 있는 문제 해결 도구(알고리즘)를 재사용하는 경우에는 개발 기간과 비용을 단축하고 신뢰성을 확보할 수 있다.
    
![Untitled 2](https://user-images.githubusercontent.com/87224039/135745596-66397e16-cede-4807-8c1b-5bed4b88029b.png)


    
- 객체지향 설계 방법(Object-Oriented Design)
    
    객체지향 설계 방법에서는 작은 단위의 문제 해ㅐ결을 위한 자료와 처리 방법을 하나로 묶어서 객체를 만들고, 객체를 연결하여 재사용 한다. 하위 단위의 문제 해결 도구(알고리즘)를 재사용한다는 점에서 상향식 설계 방법과 유사하나, 자료와 처리 방법이 하나의 객체로 만들어진다는 차이가 있다.
    

## Ⅰ-4 구현

구현 단계는 설계 단계에서 논리적으로 결정한 문제 해결 방법(알고리즘)을 C, C++, JAVA 등의 특정 프로그래밍 언어를 사용하여 실제로 프로그램을 작성하는 단계이다.

따라서, 구현 단계에서는 사용할 프로그래밍 언어를 선택해야 하고, 프로그래밍 기법과 스타일, 프로그래밍 순서 등을 결정해야한다.

- 프로그래밍 기법 2가지 (구조화, 모듈러)
    
    주로 사용하는 프로그래밍 기법으로는 구조화 프로그래밍과 모듈러 프로그래밍이 있다.
    
    - 구조화 프로그래밍
        
        지정문과 조건문, 반복분만 사용하여 프로그램을 작성함으로써 순차 구조, 선택 구조, 반복 구조의 3가지 제어 구조로 표현하는 프로그래밍 기법이다.
        
        3가지 제어 구조만 사용하므로 구조가 간단하고 명확하여 정확성 검증과 테스트, 유지 보수가 쉽다는 장점이 있다.
        
    - 모듈러 프로그래밍
        
        프로그램을 여러 개의 작은 모듈로 나누어서 계층 관계를 갖도록 구성하는 프로그래밍 기법이다.
        
        각각의 모듈은 구조화 프로그래밍 기법으로 작성하고 기본적으로 하나의 기능만 수행하도록 구성한다.
        
        모듈별로 개발과 테스트, 유지 보수가 가능할 뿐만 아니라 재사용도 가능하다.
        

## Ⅰ-5 테스트

테스트 단계는 개발한 시스템이 요구사항을 만족하는지, 실행 결과가 예상한 결과와 정확하게 맞는지를 검사하고 평가하는 일련의 과정으로서, 숨어있는 오류를 최대한 찾아내어 시스템의 완성도를 높이는 것을 목적으로 한다.

테스트는 일반적으로 단위 테스트(Unit Test), 통합  테스트(Integration Test), 인수 테스트(Acceptance Test) 이렇게 3단계로 시행한다.

- 단위 테스트(Unit Test)
    
    시스템의 최소 구성 요소가 되는 모듈에 대해 개별적으로 시행하여 요구 사항 명세서에 기술 된 기능을 제대로 수행하는지를 테스트한다.
    
- 통합 테스트(Integration Test)
    
    통합 테스트는 단위 테스트를 통과한 모듈을 통합하여 전체 시스템을 완성하기 전에 모듈 간의 호출과 리턴 등 모듈 간의 인터페이스를 테스트한다.
    
    통합 테스트는 전체 모듈을 한 번에 테스트하는 것으로, 오류를 발견했을 때 그 오류가 어디에서 발생했는지 찾기 어려울 수 있다.
    
    따라서 먼저 최소의 모듈을 연결하여 작은 구성요소로 통합 테스트를 진행하고, 점진적으로 다른 연관  모듈을 연결하면서 전체 시스템을 테스트하는 것이 효율적이다.
    
- 인수 테스트(Acceptance Test)
    
    개발이 완료된 시스템을 완성된 제품으로 보고 실제 자료를 사용하여 시스템을 테스트하는 과정이다. 시스템이 실질적으로 사용되기 전에 마지막으로 수행되는 테스트이다.
    
    인수 테스트의 방법에는 시스템을 사용할 환경에 설치한 후 테스트하는 알파 테스트(Alpha Test)와 제품을 판매하기 전에 제품을 사용할 의사가 있는 잠정적 고객들이 실제로 사용해보도록 하여 개발자가 찾지 못한 오류를 찾아내는 베타 테스트(Beta Test)가 있다.
    

## Ⅰ-6 유지 보수

유지보수 단계는 시스템이 인수되고 설치된 후 일어나는 모든 활동을 의미한다. 소프트웨어 생명 주기에서 가장 긴 기간이 된다.

유지 보수의 유형으로는 수정형, 적응형, 완전형, 예방형이 있다.

- 수정형 유지 보수
    
    사용 중에 발견한 프로그램의 오류를 수정하는 작업
    
- 적응형 유지 보수
    
    시스템과 관련한 환경적 변화에 적응하도록 재조정하는 작업
    
- 완전형 유지 보수
    
    시스템의 성능을 향상시키기 위해 개선하는 작업
    
- 예방형 유지 보수
    
    앞으로 발생할지 모를 변경 사항을 수용할 수 있도록 미리 대비하는 작업
    

개발된 소프트웨어의 품질은 정확성, 유지 보수성, 무결성, 사용성 등에 따라 평가한다.

- 정확성
    
    요구되는 기능들을 소프트웨어가 정확하게 수행하는 정도를 말하는 것으로 정확하게 작동하지 않으면 의미가 없다.
    
- 유지 보수성
    
    사용하는 동안 사용 환경이나 사용자의 요구 사항이 변경되었을 때 변경 사항을 쉽게 수용할 수 있는지를 나타낸다.
    
- 무결성
    
    바이러스 같은 외부의 공격에 대해 문제가 발생하지 않는 보안성을 의미한다.
    
- 사용성
    
    사용자가 쉽게 사용법을 배우고 편하게 사용할 수 있는 정도를 나타낸다.
    

이런 관점에서 본다면 성공한 소프트웨어란 정확하고, 사용 환경의 변화에 쉽게 적응하며 보안 기능이 갖춰진, 널리 사용되는 소프트웨어라고 정의할 수 있다.

# Ⅱ. 추상 자료형

---

추상화는 무엇인가(What)를 논리적으로 정의하는 것이고,

구체화는 어떻게 할 것인지(How)를 실제적으로 표현하는 것이다.

우리나라 속담에 '귀에 걸면 귀걸이, 코에 걸면 코걸이' 라는 말이 있다. 

이것은 하나의 사물을 어떻게 사용하느냐에 따라서 그 용도가 정해진다는 뜻이다.

추상화와 구체화의 개념에서 생각해보면, '고리'는 추상화된 기본 틀이고, 이 기본 틀을 용도에 맞게 귀걸이나 코걸이로 실제 사용하는 것은 구체화에 해당된다.

![Untitled 3](https://user-images.githubusercontent.com/87224039/135745607-91537d5e-6cb1-4d41-96b4-b6814d602bc7.png)



자료와 연산에 있어서 추상화와 구체화의 관계는 아래 표와 같다.

![Untitled 4](https://user-images.githubusercontent.com/87224039/135745608-f09ddbdd-3059-4586-b4b4-866b70cf3fd9.png)



# Ⅲ. 알고리즘

---

알고리즘(Algorithm)은 주어진 문제를 해결하기 위한 방법을 추상화 하여 일련의 단계적 절차를 논리적으로 기술해놓은 명세서이다.

알고리즘은 입력, 출력, 명확성, 유한성, 효과성에 대한 조건을 만족해야 한다.

```c
if (조건식) then 명령문 1;
else 명령문2;
```

조건식이 참이면 then 다음의 명령문 1이 수행되고, 조건식이 거짓이면 else 다음의 명령문 2가 수행된다.

11.

알고리즘의 성능 분석은 실행에 필요한 공간 측면에서 분석하는 공간 복잡도와

실행에서 소요되는 시간 측면에서 분석하는 시간 복잡도를 추정하여 일반적인 평가를 한다.

# Ⅳ. 성능 분석

12.

공간 복잡도는 알고리즘을 프로그램으로 실행하여 완료하는데 필요한 총 저장 공간을 의미하는 것으로 고정 공간량과 가변 공간량의 합으로 구할 수 있다.

시간 복잡도는 알고리즘을 프로그램으로 실행하여 완료하는데 걸리는 시간을 의미하며, 프로그램의 컴파일 시간과 실행 시간의 합으로 표현한다.

시간 복잡도를 나타낼 때 빅-오(Big Oh) 표기법을 사용한다.
